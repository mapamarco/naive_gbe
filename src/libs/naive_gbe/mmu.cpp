//
//            Copyright (c) Marco Amorim 2020.
// Distributed under the Boost Software License, Version 1.0.
//    (See accompanying file LICENSE_1_0.txt or copy at
//          http://www.boost.org/LICENSE_1_0.txt)
//
#include <naive_gbe/mmu.hpp>

#include <cassert>
#include <functional>
#include <algorithm>
#include <iomanip>
#include <chrono>
#include <cassert>

namespace naive_gbe
{
	mmu::mmu()
	{
		bootstrap_ = get_bootstrap();
		reset();
	}

	address& mmu::operator[](std::uint16_t addr)
	{
		return memory_[addr];
	}

	address const& mmu::operator[](std::uint16_t addr) const
	{
		return memory_[addr];
	}

	void mmu::set_bootstrap(buffer&& bootstrap)
	{
		bootstrap_ = bootstrap;
	}

	void mmu::set_cartridge(cartridge&& cartridge)
	{
		cartridge_ = cartridge;

		std::uint16_t addr = 0x0000;
		std::uint8_t* data = nullptr;

		addr = 0x0100;
		data = cartridge_.get_data().data() + 0x0100;
		while (addr < 0x014f)
			memory_[addr++].set(data++, address::access_mode::READ_ONLY);
	}

	void mmu::reset()
	{
		memory_.assign(0x10000, address{ 0, address::access_mode::READ_WRITE });

		invalid_.assign(0x10000, 0);
		video_ram_.assign(0x2000, 0);

		std::size_t addr = 0x0000;
		std::uint8_t* data = nullptr;

		addr = 0x0000;
		data = invalid_.data();
		while (addr < 0x10000)
			memory_[addr++].set(data++, address::access_mode::READ_WRITE);

		addr = 0x0000;
		data = bootstrap_.data();
		while (addr < 0x0100)
			memory_[addr++].set(data++, address::access_mode::READ_ONLY);

		addr = 0x8000;
		data = video_ram_.data();
		while (addr < 0x9fff)
			memory_[addr++].set(data++, address::access_mode::READ_WRITE);

		memory_[0xff50].set(std::bind(&mmu::disable_bootstrap, this, std::placeholders::_1));

		if (!cartridge_.get_data().empty())
		{
			addr = 0x0100;
			data = cartridge_.get_data().data() + 0x0100;
			while (addr < 0x014f)
				memory_[addr++].set(data++, address::access_mode::READ_ONLY);
		}
	}

	void mmu::assign(std::uint16_t addr, std::size_t size, std::uint8_t* data, address::access_mode mode)
	{
		while (addr < addr + size)
			memory_[addr++].set(data++, mode);
	}

	void mmu::disable_bootstrap(std::uint8_t value)
	{
		std::uint16_t addr = 0x0000;
		std::uint8_t* data = nullptr;

		addr = 0x0000;
		data = cartridge_.get_data().data();
		while (addr < 0x7fff)
			memory_[addr++].set(data++, address::access_mode::READ_ONLY);
	}

	buffer mmu::get_bootstrap() const
	{
		return
		{
			0x31, 0xfe, 0xff, 0xaf, 0x21, 0xff, 0x9f, 0x32,
			0xcb, 0x7c, 0x20, 0xfb, 0x21, 0x26, 0xff, 0x0e,
			0x11, 0x3e, 0x80, 0x32, 0xe2, 0x0c, 0x3e, 0xf3,
			0xe2, 0x32, 0x3e, 0x77, 0x77, 0x3e, 0xfc, 0xe0,
			0x47, 0x11, 0x04, 0x01, 0x21, 0x10, 0x80, 0x1a,
			0xcd, 0x95, 0x00, 0xcd, 0x96, 0x00, 0x13, 0x7b,
			0xfe, 0x34, 0x20, 0xf3, 0x11, 0xd8, 0x00, 0x06,
			0x08, 0x1a, 0x13, 0x22, 0x23, 0x05, 0x20, 0xf9,
			0x3e, 0x19, 0xea, 0x10, 0x99, 0x21, 0x2f, 0x99,
			0x0e, 0x0c, 0x3d, 0x28, 0x08, 0x32, 0x0d, 0x20,
			0xf9, 0x2e, 0x0f, 0x18, 0xf3, 0x67, 0x3e, 0x64,
			0x57, 0xe0, 0x42, 0x3e, 0x91, 0xe0, 0x40, 0x04,
			0x1e, 0x02, 0x0e, 0x0c, 0xf0, 0x44, 0xfe, 0x90,
			0x20, 0xfa, 0x0d, 0x20, 0xf7, 0x1d, 0x20, 0xf2,
			0x0e, 0x13, 0x24, 0x7c, 0x1e, 0x83, 0xfe, 0x62,
			0x28, 0x06, 0x1e, 0xc1, 0xfe, 0x64, 0x20, 0x06,
			0x7b, 0xe2, 0x0c, 0x3e, 0x87, 0xe2, 0xf0, 0x42,
			0x90, 0xe0, 0x42, 0x15, 0x20, 0xd2, 0x05, 0x20,
			0x4f, 0x16, 0x20, 0x18, 0xcb, 0x4f, 0x06, 0x04,
			0xc5, 0xcb, 0x11, 0x17, 0xc1, 0xcb, 0x11, 0x17,
			0x05, 0x20, 0xf5, 0x22, 0x23, 0x22, 0x23, 0xc9,
			0xce, 0xed, 0x66, 0x66, 0xcc, 0x0d, 0x00, 0x0b,
			0x03, 0x73, 0x00, 0x83, 0x00, 0x0c, 0x00, 0x0d,
			0x00, 0x08, 0x11, 0x1f, 0x88, 0x89, 0x00, 0x0e,
			0xdc, 0xcc, 0x6e, 0xe6, 0xdd, 0xdd, 0xd9, 0x99,
			0xbb, 0xbb, 0x67, 0x63, 0x6e, 0x0e, 0xec, 0xcc,
			0xdd, 0xdc, 0x99, 0x9f, 0xbb, 0xb9, 0x33, 0x3e,
			0x3c, 0x42, 0xb9, 0xa5, 0xb9, 0xa5, 0x42, 0x3c,
			0x21, 0x04, 0x01, 0x11, 0xa8, 0x00, 0x1a, 0x13,
			0xbe, 0x20, 0xfe, 0x23, 0x7d, 0xfe, 0x34, 0x20,
			0xf5, 0x06, 0x19, 0x78, 0x86, 0x23, 0x05, 0x20,
			0xfb, 0x86, 0x20, 0xfe, 0x3e, 0x01, 0xe0, 0x50
		};
	}
}

